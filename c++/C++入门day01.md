### 差别 
- << 表示后街输出内容，但是在变量操作的时候表示，位左移
- 

### 命名空间（解决命名的冲突）
==using namespace std;==
双冒号::，作用域运算符
![[Pasted image 20230222172834.png]]
如果在局部想要用全局变量的话，可以加上      ::atk，其中 :: 前面什么都不加
如果不加using namespace std; 这个时候就要加上std::cout和std::endl，因为这个cout和endl是std作用域下的api？
- 还有的应用就是在出现二义性的时候，比方说include了两个文件，两个文件都定义了名字相同的函数，这个时候就体现出了  ::  的重要性了。
 ![[Pasted image 20230222174400.png]]
- 这样就是设置了一个命名空间了
![[Pasted image 20230222203630.png]]
这样就可以使用命名空间
- 命名空间下可以放的东西：变量、函数、结构体、类
- 命令空间必须要申明在全局下（不可以命名在局部的作用域上）
- 命名空间可以嵌套命名空间
![[Pasted image 20230222213017.png]]
- 命名空间是开放的，可以随时给命名空间添加新成员（是合并，不是覆盖）
![[Pasted image 20230222213149.png]]
- 命名空间可以是匿名的
![[Pasted image 20230222213418.png]]
实际上就是全局静态的了，函数就是全局静态函数，变量就是全局静态变量
`全局静态变量和静态函数的一些性质：只能在本文件中使用，生命周期延长到程序结束（守护）`
- 命名空间可以取别名
![[Pasted image 20230222213853.png]]
这样取了别名以后，也能调用到了
#### 命名空间的性质
![[Pasted image 20230222215253.png]]



### 面向对象的代码风格
![[Pasted image 20230222172509.png]]


### 面向对象的三大特性
- 封装
- 继承
- 多态

### using申明
![[Pasted image 20230222215435.png]]
- 假如是这样呢？
![[Pasted image 20230222215518.png]]
![[Pasted image 20230222215936.png]]
在局部定义了变量，又进行了申明，就会出现错误
即使是改成了这样，也会出相同的错误（意思就是，这个报错是与访问方式是无关的，就是申明的问题）
![[Pasted image 20230222220049.png]]
- 当using申明与就近原则同时出现的时候就会报错
- 这里只是让sunwukongID声明成了KingGlory的

==注意一下==，上面那个是using声明，下面就这个是using编译（上面相当于是特别强调了）
- 当using的编译指令与就近原则同时出现的时候，使用就近
![[Pasted image 20230222221534.png]]

- 当然还有可能是这种情况，有两个命名空间
![[Pasted image 20230222221757.png]]
这个时候也是报错
当然可以通过加 KingGlory::sunwukongID 来避免错误

然而基本上很少自己编辑命名空间，通常都是应用别人的，除非自己封装

#### using声明总结
![[Pasted image 20230222222718.png]]

### C++和 C 的区别
#### 全局变量检测增强
![[Pasted image 20230222222840.png]]
- 这段代码在 C 语言中可以通过，但是在 C++ 中直接报错

#### 函数检测增强
![[Pasted image 20230222223123.png]]
- 上面这段代码在 C 语言中不会报错，可编译通过。但在 C++ 中直接报错
- C++ 非常严格，返回值检测、形参类型检测、函数调用参数个数

#### 类型检测转换增强
![[Pasted image 20230222223529.png]]
这段代码在 C++ 中报错，这个一定要强转（也就是说，去掉了隐式类型转换）

#### 结构体增强

^0f3ea0

![[Pasted image 20230222223732.png]]
- C语言下，结构体里面是不能有函数类型
![[Pasted image 20230222223837.png]]
- C语言下，创建结构体变量的时候，必须加关键字struct
==但是==
![[Pasted image 20230222224128.png]]
为什么要有函数，就是可以修改结构体变量里面的值

#### 布尔类型
![[Pasted image 20230223073825.png]]
- sizeof(bool)==1

#### 三目运算符的增强
![[Pasted image 20230223074218.png]]
- 意思就是：C++里面，如果 a>b，返回的是 a 这个变量，否则返回 b 这个变量。注意返回的是变量。这里返回的是 b ，然后将 b 赋值为 100
- 而在 C 下面，返回值，这里是返回了 20 ，将 20 赋值为 100，很明显是行不通的（内存中的常量区）
不过在 C 语言下可以这样操作（返回地址，然后解引用）
![[Pasted image 20230223074653.png]]
- 运算的优先性，以及结合性（下面的两种是不一样的）
![[Pasted image 20230223074915.png]]
- 下面这条返回的是 b=100 这一个表达式。如果 a<b，那么就会返回 a这个变量，否则，返回 b=100 ，这个表达式，这里返回的是变量 a
![[Pasted image 20230223074918.png]]
==注意运算的优先性

#### const增强
![[Pasted image 20230223075747.png]]
- 在 C 语言下，全局const是在常量区。当然，无论是全局的，还是局部的，都不能用来初始化数组
- 在 C++ 中有严格的类型转换，这里int 和 const int 很显然是不同的，这个是不等价的，这个要有
```C++
int* p = (int*)&m_A;
```
- 当然，全局静态变量还是没法修改的
![[Pasted image 20230223080007.png]]
- 但是，C++ 中const修饰的就是常量（不管是不是全局或者是局部）（这在 C 中是伪常量）
![[Pasted image 20230223080442.png]]
==为什么 C++ 中就可以这样操作？==
- C++ 在初始化常量的时候，不是分配在了栈区（不清楚，这句话可能不是这么说的），而且分配在了一个符号表中（如下图）（符号表中是以 key-value 的形式存储数据的）
![[Pasted image 20230223081124.png]]
==那指针到底是指向了哪里？==
![[Pasted image 20230223081207.png]]
编译器是帮你创建了一个临时变量，然后让指针指向了这个临时变量，再进行的修改
*C++中的const 可以称之为常量* ^c15833

#### 全局const区别（链接）
- 如果使用extern，那么只要在同一目录下，不包含头文件都能直使用。这一步是在链接的时候才做。这个时候如果骗了编译器，那么就会报错：一个无法解析的外部命令！（意思就是没有找到）[[编译过程解析#^2c4a42]]
- （复习一下）头文件展开是哪个步骤？[[编译过程解析#^e094b8]]
==区别==
- C 语言下const修饰的全局变量默认是外部链接属性，就是在另一个文件中只写一段
```C
const int g_a=100;
```
然后在main.c中写
```C
int main(void){
	extern const int g_a;
}
```
这个时候没啥毛病

- C++ 下const修饰的全局变量默认是外部链接属性，这个时候在另一个文件中写
```C++
const int g_a=100;
```
然后main.c中写
```C++
int main(void)
{
	extern const int g_a;
}
```
这个时候就会报错：一个无法解析的外部命令！
但是在这样定义：
```C++
extern const int g_a=100;  // 可以加extern关键字提高变量的作用域
```
*其实这个是因为在 C 语言下，隐式的加上了extern关键字*

#### const 分配内存的情况（重点）
##### 对const变量取地址，会分配临时内存
- 因为const实际上是不分配内存的，但是会放在符号表中 ^c60084
- 不过，要是取地址的话，会分配临时内存
![[Pasted image 20230223112832.png]]
##### 使用普通变量初始化const变量
![[Pasted image 20230223114011.png]]
- 这样是可以修改成功的，因为没有放在 *符号表* 中，而是放在了栈区中，实际上只要分配在了内存当中，就可以修改他的值[[C++入门day01#^c15833]] ^779d12
##### 对于自定义数据类型
![[Pasted image 20230223114541.png]]
- 这里，const Person p还是会分配内存，所以一定还是会可以使用指针修改的
- 这里使用了一个类string，要有包含头文件```#include <string>```，当然有了const关键字的保护，直接修改当然是没法改的，所以依然可以使用指针进行修改
##### 综上
const内存分配的情况的时候，只有```const int a=10;```这种最为特殊，这种是直接放在符号表之中，其他情况类似于 C 语言
##### 以后使用const来替代#define
![[Pasted image 20230223115445.png]]
- 上面这里也指出，实际上 \#define 实际上是无视作用域的，就是他在文件中间函数中间都是全局的
- 如何卸载宏？\#undefine

### 引用（重点）
![[Pasted image 20230223120103.png]]
- 引用： & 在等号左边（又是一个新用法）！
- 取地址：& 在等号右边
- 非常像 unix 下面的硬链接
##### 引用必须要初始化
![[Pasted image 20230223120356.png]]
##### 引用一旦初始化以后，就不可以引向其他变量
![[Pasted image 20230223120500.png]]
这里输出的结果是：a=b=c=100
##### 对数组建立引用
1. 直接建立引用
![[Pasted image 20230223120752.png]]
2. 先定义出数组类型，再通过类型定义引用
![[Pasted image 20230223120927.png]]
- 实际上数组是一种自定义类型，这里的类型是 int[10] ，这里的别名是 ARRAY_TYPE
##### 参数传递的方式及其注意事项
比方说，使用函数交换两个变量，有下面两种方式
1. 地址传递（非常简单）
2. 引用传递（这个要注意一下，没有见过）
![[Pasted image 20230223122126.png]]
感觉突然明白了传参的意思！
1. 对于地址传递的时候，实际上的代码是```int* p=&a;```
2. 对于引用传递的时候，实际上的代码是```int &p=a;```
3. 对于值传递的时候，实际上的代码是```int m=a;```其中这个m是全新开辟的
- 这里实际上提供了一种思路，实际上简化了代码，就是把\*p的\*给简化掉了，可以直接进行操作
##### 引用必须引用一块合法的内存空间（其实和指针差不多）
1. 不要引用常量（指针其实可以指向常量区，但是不能修改） ^472bdc
2. 不要返回局部变量的引用（当然也不能完全这么说，要理解本质：内存）（因为这里返回了局部变量的值，函数调用结束后，局部变量就会被释放掉，所以就不能返回局部变量的引用）（但是假如延长了局部变量的生命周期以后，那就可以达到一些很神奇的效果）
3. 当函数的返回值是引用的时候，函数可以作为左值进行计算
##### 引用传递还有一种很特殊的情况
- 这个是函数局部变量 + 生命周期延长的情况（这样就可以进行操作）（也就是上面的 2）
```C++
int& func()
{
	static int a = 10;
	return a;
}
```
- 但是还不止如此（也就是上面的 3）
```C++
int& func()
{
	static int a = 10;
	return a;
}
void test()
{
	func() = 1000;
}
```
##### 引用的本质
- 引用的本质实际上是一个指针常量
```C++
int& aRef = a;
aRef = 20;
```
这段代码在编译过程中的实现实际上是下面这样（编译器帮我们实现）
```C++
int* const aRef = a;
*aRef = 20;  // 编译器内部发现这个是引用，就会自动帮我们转换成这样
```
- 注意==指针常量==和==常量指针==的区别
这里是一个指针常量，也就是 `int* const aRef` ，这里显然是不能直接修改指针的指向嘞
##### 指针的引用
知道引用的一些特性以后，有什么好使的呢？指针的引用！！！
首先回想一下，就是假如传参要传递指针呢？
```C
void allocateSpace(int** a)
{
	*a = malloc(sizeof(int));
}
int main(void)
{
	int* p = NULL;
	allocateSpace(&p);
}
```
回顾一下这段代码，为什么这里要传地址？
- 如果传的不是地址，那岂不是很搞笑，就是将一个NULL传入了函数中，那岂不是很搞笑，那就相当于是创建了一个二级指针，这个二级指针指向的地址是NULL，那这个NULL二级解引用岂不是贼搞笑
- 如果allocate里面不是二级指针，这里相当于是新创建了一个一级指针，在allocateSpace中就有
```C
int main(void)
{
	int* p = NULL;
	int* a = &p;
	*a = malloc(sizeof(int));
}
```
就出现了一个滑稽的现象：这里a解引用之后，就相当于是 NULL = malloc;这肯定是不行的
但是，其实还可以这样做
```C++
void allocateSpace(int* &p)
{
	...
}
int main(void)
{
	int* p = NULL;
	allocateSpace(p);
}
```
##### 常量区的引用
![[Pasted image 20230224201235.png]]
[[C++入门day01#^472bdc]]上面说是不要引用常量区，但是假如加了`const`就可以引用常量区，并且是可以进行修改的。这里下面的逻辑就是`int temp=10;const int &ref=temp;`（只要是在内存里的，就能改）
这里又和上面有差别[[C++入门day01#^c15833]]
##### 常量引用的使用场景（修饰形参，防止误操作）
![[Pasted image 20230224202124.png]]






