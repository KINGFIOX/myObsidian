### 单例模式复习
- 步骤：
1. 将构造函数私有化，禁止创建对象。这里先私有化 默认构造 和 有参构造
2. 什么样的方式只有一个值？静态成员变量！并且可以直接使用类调用！
3. 静态成员，类内声明，类外初始化，在堆区new出来
4. 但是这样还是没有接口，提供只读接口（所以这个静态成员是私有的）!
5. 将拷贝构造禁用（私有化！）但是，实际上自行提供了拷贝构造，编译器也不会提供其他构造了
等等，感觉这个只读接口4.还是有点不清楚

如果没有将这个静态成员设置为私有属性，那么可能就会出现一个问题
```C++
ChairMan::sigleman = NULL;
```
我可以直接将类里面的指针置空。反正就是不允许有这样的代码

那么我可以先让`ChairMan::sigleman`设置为私有属性。但是这样外界没法访问。那就要提供接口。也就是涉及一个函数，这个函数返回sigleman的内容，当然这个sigleman的数据类型是一个指针，然后里面存的值是一串地址。只要返回这一串地址就行了，不暴露类里面的成员变量。

### 常函数和常对象复习
只有常函数和常对象才有mutable

### 仿函数复习
```C++
class MyClass{
public:
	int operator()(int a, int b){
		return a+b.
	}
}
```
像上面这个类，可以创建一个对象`MyAdd`来实现仿函数，即`MyAdd(1,2)`
但是，还可以使用匿名函数来实现仿函数，比方说`MyClass(1,4)`，一样可以实现仿函数。这里本质上是创建了一个匿名对象，并且这条语句调用完以后就立即释放

### 父类和其他类复习
父类->其他类->自身类

### 初始化列表语法调用父类构造函数
- 也可以使用默认构造

### 继承中的同名成员处理
- 子类会将父类中的同名成员隐藏
- 两个双冒号`::`：
1. 通过类名访问成员
2. 作用域运算符

### 多态的基本概念
下面是多态的一些好处
![[Pasted image 20230301211504.png]]
多态分为：
1. 静态多态：实际上已经学完了，就是函数的重载
- 意思就是：函数名相同，但是函数的参数不同，可以有多种形态去调用。
- 运算符的重载也是静态多态
![[Pasted image 20230301211950.png]]
1. 动态多态（一般人提到的都是动态的多态）
##### 静态？动态？主要区别：
函数地址的早绑定（静态联编）晚绑定（动态联编）
![[Pasted image 20230301211938.png]]
##### 对于有父子关系的 指针或者引用 可以直接转换的
- 但是传值是不能直接转换的
![[Pasted image 20230301212446.png]]
这里传参的代码意思是：Animal animal& = cat;
然后这里的输出结果是 “动物在说话”
实际上，这里的地址是早就绑定好了的，属于静态联编
这里绑定的地址，一定是animal中的speak的函数地址

但是，我们想要的效果不是这样的
- 如果我们想要调用“小猫在说话”，这个时候函数的地址是不能早就绑定好
- 而是在运行阶段再去绑定函数地址，属于晚绑定，叫：动态联编
那么该怎么操作？在animal这个父类中的speak成员函数声明前面加关键字virtual
那么这个`virtual void speak()`本质上发生了改变，这个函数叫做虚函数

### 多态的产生条件：
1. 有继承关系
2. 父类中有虚函数
3. 子类中重写父类的虚函数
- 子类在发生重写的时候，函数前面可以加上关键字virtual，当然也可以不加
4. 调用：父类的指针或引用，来指向子类的对象
- void speak(Animal animal&)

### 虚函数的原理
我们先看一下下面这个代码
```C++
class Animal{
public:
	void speak(){
		cout<<"动物在说话"<<endl;
	}
}
```
在没有加关键字virtual之前，这只是一个普通成员函数。但是实际上class Animal是一个空类。因为函数和普通成员变量是分来储存的。这个时候sizeof(Animal)=1。
但是，给`void speak()`变成了`virtual void speak()`以后，再来sizeof(Animal)=4;说明这个类的内容发生了改变
- 这个时候会多出来一个指针：vfptr，所以说sizeof(Animal)\==4，因为类成员里面有一个指针（当然假如是x64bit的系统，这个sizeof(Animal)\==8 ，不过vs默认好像是编译成x32bit的）
- v: virtual
- f: function
- ptr: pointer
- vfptr：虚函数指针！（或者是 虚函数表指针！）
vfptr指针指向了哪里？vftable（虚函数表！）
这个虚函数表里面记录了什么？虚函数的入口地址
也就是 &Animal::speak
- & 取地址
- Animal:: 作用域
知道了这些概念以后，我们看一下Animal类的内存结构图
（目前只有virtual void speak这个成员函数）
![[Pasted image 20230301215723.png]]
然后我们创建了子类Cat，子类继承了父类Animal
此时，Cat中也有一个vfptr以及vfptr指向的vftable
如果cat中出现了一个重写`void speak`
这里定义一下重写的条件（严格！）：
1. 函数返回值相同
2. 函数名相同
3. 形参列表相同
当子类发生重写的时候，那么原本继承父类的这个指针vfptr，指针所指向的vftable中对应的函数，其地址会发生覆盖，即此时vftable的内容是`&Cat::speak`

当然像这样的虚函数表，或者是虚基类表都是可以通过指针的偏移来实现的
我这里是没怎么理解这一点。主要是我既没有可以查看对象结构的工具，然后对这也不是很理解
但是我有了一点自己的想法了。
实际上在上面也说明了，就是这个类有一个成员，这个成员是vfptr，指向vftable，vftable中就有这个函数的地址 
![[Pasted image 20230301230819.png]]

> 说句题外话，假如这里面只有一个 static int a;那么这个sizeof(Animal)\==1，因为也分开存储的

> 不过，我突然想起来内存对齐！！！（这个应该是一个很关键的知识点）
> 我觉得有必要再复习一下C的提高班，就是那个指针的提高，个人认为非常重要
> 下面这个虚函数的深入剖析，还提到了调用惯例！一定要复习复习

### 虚函数深入剖析
- p是一个指针指向动物类，然后(long \*)p就可以取出来8个字节
- 然后解引用\*(long \*)p得到的是就是vftable ，表的首地址就是&Animall::speak，并且他是8字节
- 所以就取8个字节(long \*)\*(long \*)p ，这个时候得到的是一个函数地址
- 将这个地址解引用就是一个函数 (\*(long \*)\*(long \*)p)
接下来就是怎么调用这个函数？想一下函数指针是怎样调用的？回想一下 “回调函数”！
调用！((void(\*)())(\*(long \*)\*(long \*)p))()
- 突然好像就明白了 (void)(\*)() 的含义了，上面那个指的就是函数类型。
- 这里是将(\*(long \*)\*(long \*)p)这一串函数地址转换为 (void)(\*)()的函数类型
- 转化成为了这种类型以后，再通过最后面的()来进行调用

假如要调用vftable里面的第二个函数呢？
1. 先取8个字节 (long \*)p。
2. \*p中仅有的一个成员是vfptr，这是一个指针，对齐解引用\*(long \*)p
3. 这个时候再取8个字节，(long \*)\*(long \*)p 。得到的就是vftable的地址
4. vftable中有两个函数，解引用后得到的是第一个函数的地址，我们想要得到第二个函数的地址。\*(long \*)\*(long \*)p这个是第一个函数的地址
5. 我们想到得到第二个函数，就要偏移8个字节，得到了第二个函数的地址，\*(long \*)\*(long \*)p+1
6. ((void (\*)())(\*(long \*)\*(long \*)p+1))()















