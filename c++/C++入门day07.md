### 单例模式复习
- 步骤：
1. 将构造函数私有化，禁止创建对象。这里先私有化 默认构造 和 有参构造
2. 什么样的方式只有一个值？静态成员变量！并且可以直接使用类调用！
3. 静态成员，类内声明，类外初始化，在堆区new出来
4. 但是这样还是没有接口，提供只读接口（所以这个静态成员是私有的）!
5. 将拷贝构造禁用（私有化！）但是，实际上自行提供了拷贝构造，编译器也不会提供其他构造了
等等，感觉这个只读接口4.还是有点不清楚

如果没有将这个静态成员设置为私有属性，那么可能就会出现一个问题
```C++
ChairMan::sigleman = NULL;
```
我可以直接将类里面的指针置空。反正就是不允许有这样的代码

那么我可以先让`ChairMan::sigleman`设置为私有属性。但是这样外界没法访问。那就要提供接口。也就是涉及一个函数，这个函数返回sigleman的内容，当然这个sigleman的数据类型是一个指针，然后里面存的值是一串地址。只要返回这一串地址就行了，不暴露类里面的成员变量。

### 常函数和常对象复习
只有常函数和常对象才有mutable

### 仿函数复习
```C++
class MyClass{
public:
	int operator()(int a, int b){
		return a+b.
	}
}
```
像上面这个类，可以创建一个对象`MyAdd`来实现仿函数，即`MyAdd(1,2)`
但是，还可以使用匿名函数来实现仿函数，比方说`MyClass(1,4)`，一样可以实现仿函数。这里本质上是创建了一个匿名对象，并且这条语句调用完以后就立即释放

### 父类和其他类复习
父类->其他类->自身类

### 初始化列表语法调用父类构造函数
- 也可以使用默认构造

### 继承中的同名成员处理
- 子类会将父类中的同名成员隐藏
- 两个双冒号`::`：
1. 通过类名访问成员
2. 作用域运算符

### 多态的基本概念
下面是多态的一些好处
![[Pasted image 20230301211504.png]]
多态分为：
1. 静态多态：实际上已经学完了，就是函数的重载
- 意思就是：函数名相同，但是函数的参数不同，可以有多种形态去调用。
- 运算符的重载也是静态多态
![[Pasted image 20230301211950.png]]
1. 动态多态（一般人提到的都是动态的多态）
##### 静态？动态？主要区别：
函数地址的早绑定（静态联编）晚绑定（动态联编）
![[Pasted image 20230301211938.png]]
##### 对于有父子关系的 指针或者引用 可以直接转换的

^17772e

- 但是传值是不能直接转换的
![[Pasted image 20230301212446.png]]
这里传参的代码意思是：Animal animal& = cat;
然后这里的输出结果是 “动物在说话”
实际上，这里的地址是早就绑定好了的，属于静态联编
这里绑定的地址，一定是animal中的speak的函数地址

但是，我们想要的效果不是这样的
- 如果我们想要调用“小猫在说话”，这个时候函数的地址是不能早就绑定好
- 而是在运行阶段再去绑定函数地址，属于晚绑定，叫：动态联编
那么该怎么操作？在animal这个父类中的speak成员函数声明前面加关键字virtual
那么这个`virtual void speak()`本质上发生了改变，这个函数叫做虚函数

### 多态的产生条件：

^7f3474

1. 有继承关系
2. 父类中有虚函数
3. 子类中重写父类的虚函数
- 子类在发生重写的时候，函数前面可以加上关键字virtual，当然也可以不加
4. 调用：父类的指针或引用，来指向子类的对象
- void speak(Animal animal&)

### 虚函数的原理
我们先看一下下面这个代码
```C++
class Animal{
public:
	void speak(){
		cout<<"动物在说话"<<endl;
	}
}
```
在没有加关键字virtual之前，这只是一个普通成员函数。但是实际上class Animal是一个空类。因为函数和普通成员变量是分来储存的。这个时候sizeof(Animal)=1。
但是，给`void speak()`变成了`virtual void speak()`以后，再来sizeof(Animal)=4;说明这个类的内容发生了改变
- 这个时候会多出来一个指针：vfptr，所以说sizeof(Animal)\==4，因为类成员里面有一个指针（当然假如是x64bit的系统，这个sizeof(Animal)\==8 ，不过vs默认好像是编译成x32bit的）
- v: virtual
- f: function
- ptr: pointer
- vfptr：虚函数指针！（或者是 虚函数表指针！）
vfptr指针指向了哪里？vftable（虚函数表！）
这个虚函数表里面记录了什么？虚函数的入口地址
也就是 &Animal::speak
- & 取地址
- Animal:: 作用域
知道了这些概念以后，我们看一下Animal类的内存结构图
（目前只有virtual void speak这个成员函数）
![[Pasted image 20230301215723.png]]
然后我们创建了子类Cat，子类继承了父类Animal
此时，Cat中也有一个vfptr以及vfptr指向的vftable
如果cat中出现了一个重写`void speak`
这里定义一下重写的条件（严格！）：
1. 函数返回值相同
2. 函数名相同
3. 形参列表相同
当子类发生重写的时候，那么原本继承父类的这个指针vfptr，指针所指向的vftable中对应的函数，其地址会发生覆盖，即此时vftable的内容是`&Cat::speak`

当然像这样的虚函数表，或者是虚基类表都是可以通过指针的偏移来实现的
我这里是没怎么理解这一点。主要是我既没有可以查看对象结构的工具，然后对这也不是很理解
但是我有了一点自己的想法了。
实际上在上面也说明了，就是这个类有一个成员，这个成员是vfptr，指向vftable，vftable中就有这个函数的地址 
![[Pasted image 20230301230819.png]]

> 说句题外话，假如这里面只有一个 static int a;那么这个sizeof(Animal)\==1，因为也分开存储的

> 不过，我突然想起来内存对齐！！！（这个应该是一个很关键的知识点）
> 我觉得有必要再复习一下C的提高班，就是那个指针的提高，个人认为非常重要
> 下面这个虚函数的深入剖析，还提到了调用惯例！一定要复习复习

### 虚函数深入剖析
- p是一个指针指向动物类，然后(long \*)p就可以取出来8个字节
- 然后解引用\*(long \*)p得到的是就是vftable ，表的首地址就是&Animall::speak，并且他是8字节
- 所以就取8个字节(long \*)\*(long \*)p ，这个时候得到的是一个函数地址
- 将这个地址解引用就是一个函数 (\*(long \*)\*(long \*)p)
接下来就是怎么调用这个函数？想一下函数指针是怎样调用的？回想一下 “回调函数”！
调用！((void(\*)())(\*(long \*)\*(long \*)p))()
- 突然好像就明白了 (void)(\*)() 的含义了，上面那个指的就是函数类型。
- 这里是将(\*(long \*)\*(long \*)p)这一串函数地址转换为 (void)(\*)()的函数类型
- 转化成为了这种类型以后，再通过最后面的()来进行调用

假如要调用vftable里面的第二个函数呢？
1. 先取8个字节 (long \*)p。
2. \*p中仅有的一个成员是vfptr，这是一个指针，对齐解引用\*(long \*)p
3. 这个时候的\*(long \*)p是vfptr的首地址。
4. 取8个字节得到指针,(long \*)\*(long \*)p
5. 这个指针解引用以后得到的就是vftable，并且首地址是第一个函数\*(long \*)\*(long \*)p
6. 想要得到下一个函数，就要向后偏移8个字节再解引用\*((long \*)\*(long \*)p+1);
7. 转化为函数类型 (void(\*)())\*((long \*)\*(long \*)p+1);整体括起来
8. 再使用函数((void(\*)())\*((long \*)\*(long \*)p+1))();

但是，假如有一个参数呢？
![[Pasted image 20230303084344.png]]
就是假如要传一个参数进去，这个时候运行代码，能正常输出。但是代码最后会崩掉。这个调用惯例有关。回想一下之前的调用惯例：默认调用惯例__cdecl，这里使用的调用惯例实际上是__stdcall。这个主要问题是出栈方式。这个时候要明确一下
![[Pasted image 20230303084718.png]]
1. 这里是想告诉我们怎么使用调用惯例
2. 还有就是怎么使用函数指针

### 多态案例
##### 设计原则：对扩展开放，对修改封闭

### 纯虚函数
```C++
virtual int getResult() = 0;
```
就是假如原本的虚函数是一个空实现的话，可以通过这种方式来简化代码

特点：
1. 如果一个类包含纯虚函数的话，这个类是无法实例化对象，这个类我们通常称为抽象类
2. 抽象类的子类必须要重写父类中的纯虚函数，不然子类也是抽象类。如果不重写，就也继承了纯虚函数，那么这个子类也就是纯虚函数
3. 

### 虚析构
复习一下流程：
1. 就是子类创建了一个对象后：父类构造->其他类构造->子类构造
2. 析构顺序：子类->其他类->父类
（就是栈嘛，first in last out）

##### 父类的指针不会走子类的析构
但是假如在堆区上创建了一个子类对象呢？释放是有问题的。
![[Pasted image 20230303092031.png]]
这里显示的是没有调用子类的析构，假如子类析构函数中有释放堆区内存的操作，这里没有释放的话，就会导致内存泄漏。

也就是假如用多态的方式，在堆区创建了子类对象。那么在释放堆区的时候，不会走子类析构的代码。

解决方案：父类的析构函数应该要这样操作 —— 虚析构！
如果子类中有指向堆区的属性，那么要利用虚析构技术，在delete的时候，调用子类的析构函数
```C++
virtual ~Animal(){
	cout<<“animal的析构函数调用”<<endl;
}
```

##### 纯虚析构
```C++
virtual ~Animal()=0
```
但是这样的代码有问题，报错：一个无法解析的外部命令！（这个错误在链接的时候调用）
纯虚析构需要有声明，也需要有实现。万一也要释放父类中堆区的东西，那也要有实现。
```C++
Animal::~Animal(){
	cout<<"animal的纯虚析构的调用"<<endl;
}
```
纯虚析构与纯虚函数的区别？
1. 纯虚函数能实现吗？不能，因为直接等于0了（不过我就在好奇，能不能类外实现。但是类外实现也是没有意义的，因为子类要重写纯虚函数）
2. 纯虚析构要有实现（哪怕空实现也好）
- 一样的：假如要纯虚函数，那么这个类也属于抽象类，无法实例化对象

### 向上向下类型转换
##### 父转子：向下类型转换，不安全
![[Pasted image 20230303095156.png]]
怎样判断安不安全？就是看有没有寻址越界。首先开辟的是Animal大小的内存空间。但是我使用的是cat类型的指针，这个指针可以达到更多的地方！寻址越界！

##### 子转父：向上类型转换，安全
![[Pasted image 20230303095720.png]]

### 顿悟：
- 突然明白了类是怎么一回事！就是类实际上就是结构体，实际上类也是没有存放函数，只是将函数放到了另一个地方，然后套上了类的作用域！
- 为什么重写又叫做覆盖呢？就是子类在vftable中一条覆盖掉了父类的vftable的一条

### 重写、重载、重定义 复习！
##### 重载：
1. 同一个作用域
2. 函数名相同
3. 函数的参数个数、参数类型、参数顺序不同
4. const也可以作为重载的条件（参数类型不同）

##### 重写（覆盖）：
1. 继承
2. 子类重写父类的虚函数
3. 函数的返回值、函数名字、函数参数 都必须与父类一致！
- 子类重写函数可以加上virtual，也可以不加

##### 重定义：
1. 有继承
2. 子类重新定义父类的同名成员
- 这个时候，子类隐藏父类的同名成员，调用方式：作用域！

##### 一个极端的例子
```C++
class A{
public:
	// 同一作用域下，func1函数重载
	void func1(){};
	void func1(int a){};
	void func2(){};
	virtual void func3() = 0;
}

class B:public A{
public:
	// 重定义父类中的func2，隐藏父类的func2函数
	void func2(){};
	// 重写父类的func3
	virtual void func3(){};
}


```







